##Ciphertext in binary format: 	
##1100101011101101101000100110010101011111101101110011100001110011
#Key: “LOVECSND” in binary format:
#0100110001001111010101100100010101000011010100110100111001000100

cipher = "1100101011101101101000100110010101011111101101110011100001110011"
key = "0100110001001111010101100100010101000011010100110100111001000100"

pc_1 = [57,   49,    41,   33,    25,    17,    9,
               1,   58,    50,   42,    34,    26,   18,
              10,    2,    59,   51,    43,    35,   27,
              19,   11,     3,   60,    52,    44,   36,
              63,   55,    47,   39,    31,    23,   15,
               7,   62,    54,   46,    38,    30,   22,
              14,    6,    61,   53,    45,    37,   29,
              21,   13,     5,   28,    20,    12,    4]

i = 0
k = ""

left_shifts = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

for i in range(0,len(pc_1)): # generate first 56-bit permutation
    k = k+key[pc_1[i]-1]


c = []
d = []

c.append(k[:28])
d.append(k[28:])


j = 0
for i in left_shifts: # creates the rest of the cs and ds
    temp_c = c[j][i:] + c[j][:i]
    temp_d = d[j][i:] + d[j][:i]
    c.append(temp_c)
    d.append(temp_d)
    j+=1

k_subkeys = []

for i in range(1,17):
    k_subkeys.append(c[i] + d[i])


#for i in range(0, 17):
    #print("C"+str(i) + ": " + str(c[i]) + " and D"+str(i) +": " + str(d[i]))

pc_2 = [ 14,    17,   11,    24,     1,    5,
                  3,    28,   15,     6,    21,   10,
                 23,    19,   12,     4,    26,    8,
                 16,     7,   27,    20,    13,    2,
                 41,    52,   31,    37,    47,   55,
                 30,    40,   51,    45,    33,   48,
                 44,    49,   39,    56,    34,   53,
                 46,    42,   50,    36,    29,   32]

k_subkeys_perm = []
for i in range(0,16):
    temp_k_subkey = ""
    for j in range(0, len(pc_2)):
        temp_k_subkey = temp_k_subkey+k_subkeys[i][pc_2[j]-1]
    k_subkeys_perm.append(temp_k_subkey)

for i in range(0,16):
    print("K"+str(i+1)+": "+k_subkeys_perm[i])

ip = [58,    50,   42,    34,    26,   18,    10,    2,
            60,    52,   44,    36,    28,   20,    12,    4,
            62,    54,   46,    38,    30,   22,    14,    6,
            64,    56,   48,    40,    32,   24,    16,    8,
            57,    49,   41,    33,    25,   17,     9,    1,
            59,    51,   43,    35,    27,   19,    11,    3,
            61,    53,   45,    37,    29,   21,    13,    5,
            63,    55,   47,    39,    31,   23,    15,    7]

e_bit = [32,     1,    2,     3,     4,    5,
                  4,     5,    6,     7,     8,    9,
                  8,     9,   10,    11,    12,   13,
                 12,    13,   14,    15,    16,   17,
                 16,    17,   18,    19,    20,   21,
                 20,    21,   22,    23,    24,   25,
                 24,    25,   26,    27,    28,   29,
                 28,    29,   30,    31,    32,    1]



#print(m_ip)

def xor(a, b): #need to make our own xor function since using strings
    out = ""
    for i in range(0,len(a)):
        if a[i] == "0" and b[i] == "1":
            out += "1"
        elif a[i] == "1" and b[i] == "0":
            out += "1"
        else:
            out+="0"
    return out



def expand_with_ebit(r_in):
    r_out = ""
    for i in e_bit:
        r_out = r_out + r_in[i-1]
    return r_out

s = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
		 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
		 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
		 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],
         [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
		 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
		 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
		 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],
         [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
		 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
		 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
		 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],
         [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
		 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
		 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
		 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],
         [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
		 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
		 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
		 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],
         [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
		 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
		 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
		 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],
         [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
		 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
		 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
		 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],
         [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
		 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
		 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
		 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]

p = [16,   7,  20,  21,
                         29,  12,  28,  17,
                          1,  15,  23,  26,
                          5,  18,  31,  10,
                          2,   8,  24,  14,
                         32,  27,   3,   9,
                         19,  13,  30,   6,
                         22,  11,   4,  25]

ip_1= [40,     8,   48,    16,    56,   24,    64,   32,
            39,     7,   47,    15,    55,   23,    63,   31,
            38,     6,   46,    14,    54,   22,    62,   30,
            37,     5,   45,    13,    53,   21,    61,   29,
            36,     4,   44,    12,    52,   20,    60,   28,
            35,     3,   43,    11,    51,   19,   59,   27,
            34,     2,   42,    10,    50,   18,    58,   26,
            33,     1,   41,     9,   49,   17,    57,  25]

#need to use k_subkeys_perm

def f_fn(data, key):
    e_r = expand_with_ebit(data)
    xor_out = xor(key, e_r)
    output = ""
    for i in range(0,len(s)):
        cur_table = s[i]
        cur_block = xor_out[i*6:i*6+6] #6 at a time
        table_row = int(cur_block[0]+cur_block[-1],2)
        table_col = int(cur_block[1:5], 2)
        output += str(format(cur_table[table_row * 16 + table_col], '04b'))
    p_output = ""
    for i in range(0, len(p)):
        p_output += output[p[i]-1]
    return p_output

cipher_ip_1 = ["0"]*len(cipher)
for i in range(0,len(ip_1)): 
    cipher_ip_1[ip_1[i]-1]=cipher[i]

l = []
r = []

cipher_ip_1 = "".join(cipher_ip_1)

l.append(cipher_ip_1[32:])
r.append(cipher_ip_1[:32])

for i in range(0,16):
    chosen_key = k_subkeys_perm.pop(-1)
    l.append(r[i])
    r.append(xor(l[i],f_fn(r[i], chosen_key)))
    print(f"Iteration {i+1}! f = {f_fn(r[i], chosen_key)} and LnRn = {l[-1]}{r[-1]}")

semi_final = r[-1]+ l[-1]

m_ip = ["0"] * len(ip)


for i in range(0,len(ip)): # does the ip table
    m_ip[ip[i]-1] = semi_final[i]

m_ip = "".join(m_ip)

print("decoded message: " + m_ip)